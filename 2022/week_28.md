## 07-04

**OUTPUT HARDWARE**

​	Output hardware consists of external devices that transfer information from the computer’s CPU to the computer user. A video display, or screen, converts information generated by the computer into visual information. Displays commonly take one of two forms: a video screen with a **cathode ray tube(阴极射线管)** (CRT) or a video screen with a liquid crystal display (LCD). A CRT-based screen, or monitor, looks similar to a television set. Information from the CPU is displayed using a beam of electrons that scans a phosphorescent surface that emits light and creates images. An LCD-based screen displays visual information on a flatter and smaller screen than a CRT-based video monitor. LCDs are frequently used in laptop computers. 

​	Printers take text and image from a computer and print them on paper. Dot-matrix printers use tiny wires to impact upon an inked ribbon to form characters. Laser printers employ beams of light to draw images on a drum that then **picks up（捡起、吸收）** **fine black particles（黑色细小颗粒）** called **toner（粉末）**. The toner is **fused（融合）** to a page to produce an image. **Inkjet（喷墨）** printers fire **droplets（小滴）** of ink onto a page to form characters and pictures. 



**STORAGE HARDWARE** 

​	Storage hardware provides permanent storage of information and programs for **retrieval（找回）** by the computer. The two main types of storage devices are disk drives and memory. There are several types of disk drives: hard, floppy, magneto-optical, and compact. Hard disk drives store information in magnetic particles embedded in a disk. Usually a permanent part of the computer, hard disk drives can store large amounts of information and retrieve that information very quickly. Floppy disk drives also store information in magnetic particles embedded in removable disks that may be floppy or rigid. Floppy disks store less information than a hard disk drive and retrieve the information at a much slower rate. Magneto-optical disc drives store information on removable discs that are sensitive to both laser light and magnetic fields. They can typically store as much information as hard disks but have slightly slower retrieval speeds. Compact disc drives (CD-ROM) store information on pits burned into the surface of a disc of reflective material.  The information stored on CD-ROMs cannot be erased or overwritten with new information. They can store about as much information as a hard drive but have a slower rate of information retrieval. 

​	Memory refers to the computer chips that store information for quick retrieval by the CPU. Random access memory (RAM) is used to store the information and instructions that operate the computer’s programs. Typically, programs are transferred from storage on a disk drive to RAM. RAM is also known as volatile memory because the information within the computer chips is lost when power to the computer is turned off. Read-only memory (ROM) contains critical information and software that must be permanently available for computer operation, such as the operating system that directs the computer’s actions from start up to shut down. ROM is called nonvolatile memory because the memory chips do not lose their information when power to the computer is turned off. 

​	Some devices serve more than one purpose. For example, floppy disks may also be used as input devices if they contain information to be used and processed by the computer user. In addition, they can be used as output devices if the user wants to store the results of computations on them. 



**HARDWARE CONNECTIONS**

​	To function, hardware requires physical connections that allow components to communicate and interact. A bus provides a common interconnected system composed of a group of wires or circuitry that **coordinates（坐标、协调）** and moves information between the internal parts of a computer. A computer bus consists of two channels: one that the CPU uses to locate data, called the address bus, and another to send the data to that address, called the data bus. A bus is characterized by two features: how much information it can manipulate at one time, called the bus width, and how quickly it can transfer these data. 

​	A serial connection is a wire or set of wires used to transfer information from the CPU to an external device such as a mouse, keyboard, modem, scanner, and some types of printers. This type of connection transfers only one piece of data at a time, and is therefore slow. The advantage to using a serial connection is that it provides effective connections over long distances. 

​	A parallel connection uses multiple sets of wires to transfer blocks of information simultaneously. Most scanners and printers use this type of connection. A parallel connection is much faster than a serial connection, but it is limited to distances of less than 3 m (10 ft) between the CPU and the external device. 



## 07-05:

​	The PCI  bus is fine for attaching high-speed **peripherals（外围设备）** to a computer, but it is far too expensive to have a PCI interface for each low-speed I/O device such as a keyboard or mouse. Historically, each standard I/O device was connected to the computer in a special way, with some free ISA and PCI slots for adding new devices. Unfortunately, this scheme has been **fraught（充满）** with problems from the beginning. For example, each new I/O device often comes with its own ISA or PCI card. The user is often responsible for setting switches and jumpers on the card and making sure the settings do not conflict with other cards. Then the user must open up the case, carefully insert the card, close the case, and reboot the computer. For many users, this process is difficult and error **prone（倾向）**. In addition, the number of ISA and PCI slots is very limited (two or three typically). Plug ’n Play cards eliminate the jumper settings, but the user still has to open the computer to insert the card and bus slots are still limited. 

​	To deal with this problem, in the mid 1990s, **representatives（代表）** from seven companies (Compaq , DEC , IBM , Intel , Microsoft , NEC , and Northern Telecom ) got together to design a better way to attach low-speed I/O devices to a computer. Since then, hundreds of other companies have joined them. The resulting standard is called USB and it is being widely implemented in personal computers. 

​	Some of the goals of the companies that originally **conceived（构想）** of the USB and started the project were as follows: 

- Users must not have to set switches or jumpers on boards or devices. 
-  Users must not have to open the case to install new I/O devices. 
- There should be only one kind of cable, good for connecting all devices. 
-  I/O devices should get their power from the cable. 
-  Up to 127 devices should be attachable to a single computer. 
-  The system should support real-time devices (e.g., sound, telephone). 
- Devices should be installable while the computer is running. 
-  No reboot should be needed after installing a new device. 
-  The new bus and its I/O devices should be **inexpensive（廉价的）** to manufacture. 

​	USB meets all these goals. It is designed for low-speed devices such as keyboards, mice, still cameras, snapshot scanners, digital telephones, and so on. The total USB bandwidth is 1.5 MB/sec , which is enough for a **substantial（大量的、结实的）** number of these devices. This low limit was chosen to keep the cost down. 

​	A USB system consists of a root hub that plugs into the main bus (see Figure 2B-1). This hub has sockets for cables that can connect to I/O devices or to expansion hubs, to provide more sockets, so the **topology（拓扑学）** of a USB system is a tree with its root at the root hub, inside the computer. The cables have different connectors on the hub end and on the device end, to prevent people from accidentally connecting two hub sockets together. The cable consists of four wires: two for data, one for power (+5 volts), and one for ground. The signaling system transmits a 0 as a voltage transition and a 1 as the absence of a voltage transition, so long runs of 0s generate a regular pulse stream. 

​	When a new I/O device is plugged in, the root hub detects this event and interrupts the operating system. The operating system then queries the device to find out what it is and how much USB bandwidth it needs. If the operating system decides that there is enough bandwidth for the device, it assigns the new device a unique address (1 – 127) and downloads this address and other information to configuration registers inside the device. In this way, new devices can be added on-the-fly, without any user configuration required and without having to install new ISA or PCI cards. Uninitialized cards start out with address 0, so they can be addressed. To make the cabling simpler, many USB devices contain built-in hubs to accept additional USB devices. For example, a monitor might have two hub sockets to accommodate the left and right speakers. 

​	Logically, the USB system can be viewed as a set of bit pipes from the root hub to the I/O devices. Each device can split its bit pipe up into at most 16 sub-pipes for different types of data (e.g., audio and video). Within each pipe or sub-pipe, data flows from the root hub to the device or the other way . There is no traffic between two I/O devices. 

​	Precisely every 1.00 ± 0.05 msec , the root hub **broadcasts（广播）** a new frame to keep all the devices synchronized in time. A frame is associated with a bit pipe, and consists of packets, the first of which is from the root hub to the device. Subsequent packets in the frame may also be in this direction, or they may be back from the device to the root hub. A sequence of four frames is shown in Figure 2B-2. In Figure 2B-2 there is no work to be done in frames 0 and 2, so all that is needed is one SOF (Start of Frame) packet. This packet is always broadcast to all devices. Frame 1 is a poll, for example, a request to a scanner to return the bits it has found on the image it is scanning. Frame 3 consists of delivering data to some device, for example to a printer.

​	USB supports four kinds of frames: control, isochronous, bulk, and interrupt. Control frames are used to configure devices, give them commands, and inquire about their status. Isochronous frames are for real-time devices such as microphones, loudspeakers, and telephones that need to send or accept data at precise time intervals. They have a highly-predictable delay but provide no **retransmissions（重传）** in the event of errors. Bulk frames are for large transfers to or from devices with no real-time requirements such as printers. Finally, interrupt frames are needed because USB does not support interrupts. For example, instead of having the keyboard cause an interrupt whenever a key is struck, the operating system can poll it every 50 msec to collect any pending keystrokes. 

​	A frame consists of one or more packets, possibly some in each direction. Four kinds of packets exist: token, data, handshake, and special. Token packets are from the root to a device and are for system control. The SOF, IN, and OUT packets in Figure 2B-2 are token packets. The SOF (Start of Frame) packet is the first one in each frame and marks the beginning of the frame. If there is no work to do, the SOF packet is the only one in the frame. The IN token packet is a poll, asking the device to return certain data. Fields in the IN packet tell which bit pipe is being polled so the device knows which data to return (if it has multiple streams). The OUT token packet announces that data for the device will follow. A fourth type of token packet, SETUP (not shown in the figure), is used for configuration. 

​	Besides the token packet, three other kinds exist. These are DATA (used to transmit up to 64 bytes of information either way), handshake, and special packets. The format of a data packet is shown in Figure 2B-2. It consists of an 8-bit synchronization field, an 8-bit packet type (PID ), the payload, and a 16-bit CRC(Cyclic Redundancy Code) to detect errors. Three kinds of handshake packets are defined: ACK(the previous data packet was correctly received), NAK (a CRC error was detected), and STALL (please wait—I am busy right now). 

​	Now let us look at Figure 2B-2 again. Every 1.00 msec a frame must be sent from the root hub, even if there is no work. Frames 0 and 2 consist of just an SOF packet, indicating that there was no work. Frame 1 is a poll, so it starts out with SOF and IN packets from the computer to the I/O device, followed by a DATA packet from the device to the computer. The ACK packet tells the device that the data were received correctly. In case of an error, a NAK would be sent back to the device and the packet would be retransmitted for bulk data (but not for isochronous data). Frame 3 is similar in structure to frame 1, except that now the flow of data is from the computer to the device. 





## 07-06:

​	The basic CD/CD-ROM format has been around since 1980. The technology has improved since then, so higher-capacity optical disks are now economically feasible and there is great demand for them. Hollywood would dearly love to replace analog video tapes by digital disks, since disks have a higher quality, are cheaper to manufacture, last longer, take up less **shelf（货架）** space in video stores, and do not have to be **rewound（重绕）**. The consumer electronics companies are looking for a new **blockbuster（重磅）** product, and many computer companies want to add multimedia features to their software. 

​	This combination of technology and demand by three immensely rich and powerful industries has led to DVD, originally an **acronym（首字母缩略）** for Digital Video Disk, but now officially Digital Versatile Disk. DVDs use the same general design as CDs, with 120-mm injection-molded polycarbonate disks containing pits and lands that are **illuminated（照明）** by a laser **diode（二极管）** and read by a **photodetector（光电探测器）**. What is new is the use of: 

1. Smaller pits (0.4 microns versus 0.8 microns for CDs). 
2.  A tighter spiral (0.74 microns between tracks versus 1.6 microns for CDs). 
3.  A red laser (at 0.65 microns versus 0.78 microns for CDs). 

​	Together, these improvements raise the capacity sevenfold, to 4.7 GB . A 1x DVD drive operates at 1.4 MB/sec (versus 150 KB/sec for CDs). Unfortunately, the switch to the red lasers used in supermarkets means that DVD players will require a second laser or fancy conversion optics to be able to read existing CDs and CD-ROMs, something not all of them may provide. Also, reading CD-Rs and CD-RWs on a DVD drive may not be possible. 

​	Is 4.7 GB enough? Maybe. Using MPEG-2  compression (standardized in IS 13346), a 4.7 GB DVD disk can hold 133 minutes of full-screen, full-motion video at high resolution (720 × 480), as well as soundtracks in up to eight languages and subtitles in 32 more. About 92 percent of all the movies Hollywood has ever made are under 133 minutes. Nevertheless, some applications such as multimedia games or reference works may need more, and Hollywood would like to put multiple movies on the same disk, so four formats have been defined: 

1. Single-sided, single-layer (4.7 GB). 
2. Single-sided, dual-layer (8.5 GB). 
3. Double-sided, single-layer (9.4 GB).
4. Double-sided, dual-layer (17 GB). 

​	Why so many formats? In a word: politics. Philips and Sony wanted single-sided, dual-layer disks for the high capacity version, but Toshiba and Time Warner wanted double-sided, single-layer disks. Philips and Sony did not think people would be willing to turn the disks over, and Time Warner did not believe putting two layers on one side could be made to work. The compromise: all combinations, but the market will determine which ones survive. 

​	The **dual（双重）** layering technology has a reflective layer at the bottom, topped with a semireflective layer. Depending on where the laser is focused, it bounces off one layer or the other. The lower layer needs slightly larger pits and lands to be read reliably, so its capacity is slightly smaller than the upper layer’s. 

​	Double-sided disks are made by taking two 0.6-mm single-sided disks and **gluing（粘和）** them together back to back. To make the thicknesses of all versions the same, a single-sided disk consists of a 0.6-mm disk bonded to a blank **substrate（底基）** (or perhaps in the future, one consisting of 133 minutes of advertising, in the hope that people will be curious as to what is down there). The structure of the double-sided, dual-layer disk is illustrated in Figure 2C-1. 

​	DVD was devised by a **consortium（联盟）** of 10 consumer electronics companies, seven of them Japanese, in close cooperation with the major Hollywood studios (some of which are owned by the Japanese electronics companies in the consortium). The computer and telecommunications industries were not invited to the picnic, and the resulting focus was on using DVD for movie rental and sales shows. For example, standard features include real-time skipping of dirty scenes, six-channel sound, and support for Pan-and-Scan. The latter feature allows the DVD player to dynamically decide how to crop the left and right edges off movies (whose width:height ratio is 3:2) to fit on current television sets (whose aspect ratio is 4:3). 

​	Another item the computer industry probably would not have thought of is an intentional **incompatibility(不相容)** between disks intended for the United States and disks intended for Europe and yet other standards for other continents. Hollywood demanded this “feature” because new films are always released first in the United States and then shipped to Europe when the videos come out in the United States. The idea was to make sure European video stores could not buy videos in the U.S. too early, thereby reducing new movies’ European theater sales. If Hollywood had been running the computer industry, we would have had 3.5-inch floppy disks in the United States and 9-cm floppy disks in Europe. 

​	If DVD is a big success, DVD-R1 (recordable) and DVD-rewritable will be mass produced within a short time. The success of DVD is not guaranteed, however, since the cable companies have quite a different plan for delivering movies—video on demand over the cable—and the battle has barely begun.





## 07-07

**Operating System** 

**I. INTRODUCTION** 

​	An operating system (OS), in computer science, is the basic software that controls a computer. It has three major functions: it **coordinates and manipulates(协调、操作)** computer hardware, such as computer memory, printers, disks,  keyboard, mouse, and monitor; it organizes files on a variety of storage media, such as floppy disk, hard drive, compact disc, and tape; and it manages hardware errors and the loss of data. 

**II. HOW AN OS WORKS** 

​	Operating systems control different computer processes, such as running a **spreadsheet（电子表格）** program or accessing information from the computer’s memory. One important process is the interpretation of commands that allow the user to communicate with the computer. Some command interpreters are text-oriented, requiring commands to be typed in. Other command interpreters are graphically oriented and let the user communicate by pointing and clicking on an icon, an on-screen picture that represents a specific command. Beginners generally find graphically oriented interpreters easier to use, but many experienced computer users prefer text-oriented command interpreters because they are more powerful. 

​	Operating systems are either single-tasking or multitasking. The more primitive single-tasking operating systems can run only one process at a time. For instance, when the computer is printing a document, it cannot start another process or respond to new commands until the printing is completed. 

​	All modern operating systems are multitasking and can run several processes simultaneously. In most computers there is only one central processing unit (CPU), (the computational and control unit of the computer), so a multitasking OS creates the illusion of several processes running simultaneously on the CPU. The most common mechanism used to create this illusion is time-slice multitasking, whereby each process is run individually for a fixed period of time. If the process is not completed within the allotted time, it is suspended and another process is run. This exchanging of processes is called **context switching**. The OS performs the “**bookkeeping（记账、统计）**” that preserves the state of a suspended process. It also has a mechanism, called a scheduler, that determines which process will be run next. The scheduler runs short processes quickly to minimize perceptible delay. The processes appear to run simultaneously because the user’s sense of time is much slower than the processing speed of the computer. 

​	Operating systems can use virtual memory to run processes that require more main memory than is actually available. With this technique, space on the hard drive is used to mimic the extra memory needed. Accessing the hard drive is more time-consuming than accessing main memory, however, so performance of the computer slows. 



**III. CURRENT OPERATING SYSTEMS** 

​	The operating systems commonly found on personal computers are UNIX, Macintosh OS, MS-DOS, OS/2, and Windows. 

**UNIX** 

​	UNIX, in computer science, is a multiuser, multitasking operating system originally developed by Ken Thompson and Dennis Ritchie at AT&T Bell Laboratories in 1969 for use on minicomputers. UNIX exists in various forms and implementations; among these are versions developed at the University of California at Berkeley (known as BSD7 releases) and versions released by AT&T, the most recent being AT&T System V. UNIX is considered a powerful operating system which, because it is written in the C language, is more portable—less machine-specific—than other operating systems. UNIX is available in several related forms, including AIX, a version of UNIX adapted by IBM (to run on RISC -based workstations), A/UX (a graphical version for the Apple  Macintosh), and Mach (a rewritten but essentially UNIX-**compatible（兼容的）** operating system for the NeXT computer). 

​	Its popularity is due in large part to the growth of the interconnected computer network known as the Internet, the software for which initially was designed for computers that ran UNIX. **Variations（变更）** of UNIX include SunOS (distributed by SUN Microsystems Inc.), Xenix (distributed by Microsoft Corporation), and Linux 11 . UNIX and its clones support multitasking and multiple users. Its file system provides a simple means of organizing disk files and lets users protect their files from other users. The commands in UNIX are not intuitive, however, and mastering the system is difficult. 



**MS-DOS** 

​	MS-DOS is the **acronym（首字母缩写）** for Microsoft Disk Operating System. In computer science, MS-DOS—like other operating systems—**oversees（监视）** such operations as disk input and output, video support, keyboard control, and many internal functions related to program execution and file maintenance. MS-DOS is a single-tasking, single-user operating system with a command-line interface. 



**OS/2** 

​	OS/2, or Operating System 2, is an operating system developed for the personal computer in the mid-1980s by International Business Machines Corporation (IBM) and Microsoft Corporation. At the time OS/2 was introduced in late 1987, the most common personal computers were IBM-compatible computers running the Microsoft Disk Operating System (MS-DOS) and computers manufactured by Apple Computer Corporation running Apple’s system for the Macintosh (Mac OS). The Macintosh operating system included multitasking, a feature that enabled computers to run several applications simultaneously. In a computer network, multitasking allows several users on different computers to have simultaneous access to the same application or data set. OS/2 was the first operating system designed for IBM-compatible personal computers that allowed multitasking. The first version of OS/2, version 1.0, was text-oriented and lacked a graphical user interface (GUI) that would allow users to enter commands with a point-and-click input device, such as a computer mouse. A year later IBM and Microsoft released OS/2 version 1.1, which included a GUI called the **Presentation Manager（表示管理程序）**. The Presentation Manager interface contained icons, pictures or words on the screen that users could click on with a mouse to enter instructions. OS/2 version 1.1 also allowed users to have multiple windows open (windows are portions of the screen that each contain a different document or program) and included pull-down lists of commands that the user could choose by clicking on them with their mouse. 

​	IBM and Microsoft ended their collaboration on OS/2 in 1991 after Microsoft released its Windows software, a multitasking environment that ran on MS-DOS. In 1992 IBM released version 2.0 of OS/2, which ran Microsoft Windows programs and could perform multitasking of DOS operations. It also contained an object-oriented programming environment that allowed software designers to create programs using high-level, object-oriented programming languages. 

​	Subsequent versions of OS/2 offered enhanced performance and multimedia capabilities, and in 1994 IBM announced that more than 5 million copies of OS/2 had been sold since its introduction. The same year, IBM introduced a new version of OS/2 called OS/2 Warp that featured improved performance, more multimedia capabilities, an array of integrated applications, and easy access to the Internet. IBM has continued to upgrade and extend OS/2 Warp. 



Windows 

​	Windows, in computer science, is a personal computer operating system sold by Microsoft Corporation that allows users to enter commands with a point-and-click device, such as a mouse, instead of a keyboard. The Windows operating system provides users with a graphical user interface (GUI), which allows them to manipulate small pictures, called icons, on the computer screen to **issue（议题、发布）** commands. Windows is the most widely used operating system in the world. It is an extension of and replacement for Microsoft’s Disk Operating System (MS-DOS). The Windows GUI is designed to be a natural, or intuitive, work environment for the user. With Windows, the user can move a cursor around on the computer screen with a mouse. By pointing the cursor at icons and clicking buttons on the mouse, the user can issue commands to the computer to perform an action, such as starting a program, accessing a data file, or copying a data file. Other commands can be reached through pull-down or click-on menu items. The computer displays the active area in which the user is working as a window on the computer screen. The currently active window may overlap with other previously active windows that remain open on the screen. This type of GUI is said to include WIMP features: windows, icons, menus, and pointing device (such as a mouse). 

​	Computer scientists at the Xerox Corporation’s Palo Alto Research Center (PARC1 ) invented the GUI concept in the early 1970s, but this innovation was not an immediate commercial success. In 1983 Apple Computer featured a GUI in its Lisa computer. This GUI was updated and improved in its Macintosh computer, introduced in 1984. Microsoft began its development of a GUI in 1983 as an extension of its MS-DOS operating system. Microsoft’s Windows version 1.0 first appeared in 1985. In this version, the windows were **tiled（平铺）**, or presented next to each other rather than overlapping. Windows version 2.0, introduced in 1987, was designed to resemble IBM’s OS/2 Presentation Manager, another GUI operating system. Windows version 2.0 included the overlapping window feature. The more powerful version 3.0 of Windows, introduced in 1990, and subsequent versions 3.1 and 3.11 rapidly made Windows the market leader in operating systems for personal computers, in part because it was **prepackaged（预先包装）** on new personal computers. It also became the favored platform for software development. In 1993 Microsoft introduced Windows NT (New Technology). The Windows NT operating system offers 32-bit multitasking, which gives a computer the ability to run several programs simultaneously, or in parallel, at high speed. This operating system competes with IBM’s OS/2 as a platform for the intensive, high-end, networked computing environments found in many businesses. In 1995 Microsoft released a new version of Windows for personal computers called Windows 95. Windows 95 has a **sleeker（光滑）** and simpler GUI than previous versions. It offers 32-bit processing, efficient multitasking, network connections, and Internet access. Few computer users run MS-DOS or OS/2 directly. They prefer versions of UNIX or windowing systems with graphical interfaces, such as Windows 98 or the Macintosh OS, which make computer technology more accessible. However, graphical systems generally have the disadvantage of requiring more hardware—such as faster CPUs, more memory, and higher-quality monitors—than command-oriented operating systems. 



**IV. FUTURE TECHNOLOGIES** 

​	Operating systems continue to evolve. A recently developed type of OS called a distributed operating system is designed for a connected, but independent, collection of computers that share resources such as hard drives. In a distributed OS, a process can run on any computer in the network (**presumably（可能）** a computer that is **idle（闲置）**) to increase that process’s performance. All basic OS functions—such as maintaining file systems, ensuring reasonable behavior, and recovering data in the event of a partial failure—become more complex in distributed systems. 

​	Research is also being conducted that would replace the keyboard with a means of using voice or handwriting for input. Currently these types of input are **imprecise（不精确）** because people pronounce and write words very differently, making it difficult for a computer to recognize the same input from different users. However, advances in this field have led to systems that can recognize a small number of words spoken by a variety of people. In addition, software has been developed that can be taught to recognize an individual’s handwriting. 



## 07-08:

**What Is Linux?** 

​	Linux is a free UNIX clone written **from scratch（从零开始）** by Linus Torvalds and a team of programmers over the Internet. Linux aims towards POSIX **compliance（服从、遵守）** (a set of standards that show what a UNIX should be). 

​	It contains all of the features that you would expect in not only a UNIX, but any operating system. Some of the features included are true multitasking, virtual memory, the world’s fastest TCP/IP drivers, shared libraries, and of course multi-user capabilities (this means hundreds of people can use one computer at the same time, either over a network, the Internet, or on laptops/computers or terminals connected to the serial ports of that computer). Linux runs fully in protected mode (unlike Windows) and supports fully fledged 32-bit and 64-bit multitasking. 

​	Linux also has a completely free X Windows  implementation conforming to the X/Open standard. Most existing X Based programs will run under Linux without any modification. X Windows for the **uninitiated（不知情的）** is a GUI, similar to Microsoft Windows but is feature packed (and is rather large, consuming around 15-20MB).  Most Linux distributions come completely pre-configured to a factory configuration, and distributions such as RedHat Linux also have graphical based configuration utilities and installers (not unlike Windows’ Control Panel). 

​	In addition, programs intended for SCO Unix 4.2 and SVR4 will run on most Linux systems unaltered (this is due to the assistance of a driver called IBCS), for example Corel Draw! for SCO and the Dataflex database system. The Linux DOS **emulator（模拟器）**, DOSEMU, will run packets of MS-DOS applications, including some that require VGA2 or SVGA3 graphics capabilities. Windows programs can also be run inside of X-Windows with the help of an emulator called WINE. Usually, Windows programs can run up to 10 times faster than on a native system4 , due to Linux’s buffering capabilities. 

​	As usually expected from most Unices , Linux includes advanced networking capabilities. Since the people developing Linux **collaborated（合作）** and used the Internet for their development efforts, networking support came early in Linux’s development stage. Networking support in Linux is **superior（更大的）** to most other operating systems. Linux supports connection to the Internet or any other network using TCP/IP or IPX via Ethernet , fast Ethernet , ATM , modem, packet radio (X.25 protocol), ISDN, token ring, or PLIP (modified printer cable to another computer). As an Internet/WWW server, Linux is a very good choice, often out performing Windows NT, Novell and most UNIX systems on the same hardware (even multiprocessor boxes). Linux has been chosen by hundreds of thousands of ISPs, by many university computer labs, and surprisingly by many businesses—by all people that need reliable server and network performance in many different situations. 

​	Linux supports all of the most common Internet protocols, including FTP , POP , SNMP , and many more. Linux can operate as a client or as a server for all of the above and has already been widely used and tested in the above roles. 

​	Linux also fits easily and tightly into your local area network, no matter what combination of systems you might be running. Full and seamless support for Macintosh, DOS, Windows, Windows NT, Windows 95, Novell, OS/2, all using their own native protocols—Linux can do all of this in just 16MB of memory or even less (with swap space). Typically, you can have all the above running in 8MB with 16MB swap (a total of 24MB RAM). 

​	Linux is developing at a **blindingly（极其地）** fast speed, and ports exist to PowerPC4 , Macintosh, and so on. If Linus Torvalds ever does decide to abandon the project, since we have the full source code available, he can just assign somebody else to take his place. The Linux kernel development will still continue no matter what happens to Linus. Somebody else will just continue with it. 



**Performance in Windows 2000** 

**INTRODUCTION** 

​	Whether deploying the Microsoft Windows 2000 operating system on the desktop or in the most demanding Web server environment, you can expect significant performance advantages over previous releases. In addition to providing the highest levels of reliability, providing a **comprehensive（综合性）** set of features to Internet-enable your business , lowering TCO 2 through enhanced management, and adding support for new hardware devices, Windows 2000 also **delivers（提供）** better performance. Using a wide range of **benchmarks（基准）**, this paper will provide you with information on the performance improvements of Windows 2000 in different deployment scenarios. 



**CLIENT PERFORMANCE** 

​	In addition to the many new desktop features that have been added to Windows 2000 Professional such as Plug and Play, power management, single worldwide binary for all languages, **IntelliMirrorTM1（智能镜像）** management technologies, and many others, the performance on the desktop is significantly faster than Windows 95 & 98 and comparable to Windows NT Workstation 4.0. By optimizing fundamental system services such as memory management, registry access, and disk I/O, Windows 2000 is able to deliver the added benefit of new features while delivering the performance that customers expect. 



**NETWORKING PERFORMANCE** 

​	Windows 2000 is **gigabit（千兆）** ready. This means that Windows 2000 is capable of sustaining the highest levels of network throughput using gigabit adapters. For example, using network adapters designed to utilize the advanced TCP/IP features in Windows 2000 such as TCP/IP checksum offloading and large send support, Windows 2000 can deliver up to 25% better network throughput than Windows NT Server 4.0 and sustain close to 4 gigabits per second (Gbps) of data throughput. With the improved networking efficiency provided by Windows 2000, customers will benefit from higher capacity Web servers, file servers, and application servers. 



**WEB SERVER PERFORMANCE**

 The performance of Web sites running Windows NT Server 4.0 can immediately be improved by upgrading to Windows 2000. Advances have been made in Windows 2000 that significantly improve Active Server Pages (ASP  ) performance and SMP  scalability. In addition, ASP applications running in out-of-process mode perform significantly better on Windows 2000. For example, an ASP application running in out-of-process mode on Windows 2000 is as fast as the same ASP application running in the Web server process on Windows NT Server 4.0. Furthermore, the raw performance of serving static Web pages has increased significantly according to publicly available SPECWeb 96 results. 



**FILE & PRINT SERVER PERFORMANCE**

​	By improving many aspects of the file server components such as increasing the virtual size of the file cache from 496MB to 960MB, optimizing the **SMB（服务器消息块）** redirector on Windows 2000, and optimizing the Windows NT File System (NTFS2 ), Windows 2000 provides customers with a better performing and scalable file server solution. Using the NetBench  benchmark, Windows 2000 Server with Windows 2000 Professional-based clients provides up to 20% better performance than Windows NT Server 4.0 with Windows NT Workstation 4.0-based clients. In some cases, especially where the file shares are stored on a single partition, Windows 2000 provides up to 2-times better file server performance than Windows NT Server 4.0. 

​	As a print server, Windows 2000 is capable of processing up to 3-times more pages per second when compared to Windows NT Server 4.0. Moreover, print performance doesn’t degrade on Windows 2000 Server as additional printers are added. Furthermore, Windows 2000 can perform the rendering in 1/3 of the time it took on Windows NT Server 4.0 and requires 1/3 of the CPU resources. 

**APPLICATION SERVER PERFORMANCE** 

​	Windows 2000 Server is a better platform for running business applications. Better SMP **scalability（可扩展、可伸缩）**, improved networking performance, and support for more physical memory have a profound impact on the performance of Windows 2000 in an application server environment. Advances to what is now known as COM+  (formerly **COM（组对象模型）**  and Microsoft Transaction Server  ) also provide better performance to customers running COM-based applications. In addition, transaction-processing capabilities of COM+ can be used as a transaction monitor when running to improve performance of database applications. 



## 07-09:

**Programming Language** 

**I. INTRODUCTION** 

​	Programming languages, in computer science, are the artificial languages used to write a sequence of instructions (a computer program) that can be run by a computer. Similar to natural languages, such as English, programming languages have a vocabulary, grammar, and **syntax（句法）**. However, natural languages are not suited for programming computers because they are ambiguous, meaning that their vocabulary and grammatical structure may be **interpreted（解释）** in multiple ways. The languages used to program computers must have simple logical structures, and the rules for their grammar, spelling, and **punctuation（标点符号）** must be precise. 

​	Programming languages vary greatly in their **sophistication（复杂）** and in their degree of **versatility（多用）**. Some programming languages are written to **address（解决）** a particular kind of computing problem or for use on a particular model of computer system. For instance, programming languages such as FORTRAN and COBOL were written to solve certain general types of programming problems—FORTRAN for scientific applications, and COBOL for business applications. Although these languages were designed to address specific categories of computer problems, they are highly **portable（便携、可移植）**, meaning that they may be used to program many types of computers. Other languages, such as machine languages, are designed to be used by one specific model of computer system, or even by one specific computer in certain research applications. The most commonly used programming languages are highly portable and can be used to effectively solve diverse types of computing problems. Languages like C, PASCAL and BASIC fall into this category. 



**II. LANGUAGE TYPES** 

​	Programming languages can be classified as either low-level languages or high-level languages. Low-level programming languages, or machine languages, are the most basic type of programming languages and can be understood directly by a computer. Machine languages differ depending on the manufacturer and model of computer. High-level languages are programming languages that must first be translated into a machine language before they can be understood and processed by a computer. Examples of high-level languages are C, C++, PASCAL, and FORTRAN. Assembly languages are **intermediate（中间的）** languages that are very close to machine languages and do not have the level of **linguistic（语言的）** sophistication **exhibited（展现）** by other high-level languages, but must still be translated into machine language



**A. Machine Languages** 

​	In machine languages, instructions are written as sequences of 1s and 0s, called bits, that a computer can understand directly. An instruction in machine language generally tells the computer four things: (1) where to find one or two numbers or simple pieces of data in the main computer memory (Random Access Memory, or RAM), (2) a simple operation to perform, such as adding the two numbers together, (3) where in the main memory to put the result of this simple operation, and (4) where to find the next instruction to perform. While all executable programs are eventually read by the computer in machine language, they are not all programmed in machine language. It is extremely difficult to program directly in machine language because the instructions are sequences of 1s and 0s. A typical instruction in a machine language might read 10010 1100 1011 and mean add the contents of storage register A to the contents of storage register B. 

**B. High-Level Languages** 

​	High-level languages are relatively sophisticated sets of statements **utilizing（利用）** words and syntax from human language. They are more similar to normal human languages than assembly or machine languages and are therefore easier to use for writing complicated programs. These programming languages allow larger and more complicated programs to be developed faster. However, high-level languages must be translated into machine language by another program called a compiler before a computer can understand them. For this reason, programs written in a high-level language may take longer to execute and use up more memory than programs written in an assembly language. 



**C. Assembly Languages**

​	Computer programmers use assembly languages to make machine-language programs easier to write. In an assembly language, each statement **corresponds（对应）** roughly to one machine language instruction. An assembly language statement is composed with the aid of easy to remember commands. The command to add the contents of the storage register A to the contents of storage register B might be written ADD B, A in a typical assembly language statement. Assembly languages share certain features with machine languages. For instance, it is possible to manipulate specific bits in both assembly and machine languages. Programmers use assembly languages when it is important to minimize the time it takes to run a program, because the translation from assembly language to machine language is relatively simple. Assembly languages are also used when some part of the computer has to be controlled directly, such as individual dots on a monitor or the flow of individual characters to a printer. 



**III. CLASSIFICATION OF HIGH-LEVEL LANGUAGES**

 	High-level languages are commonly classified as procedure-oriented, functional, object-oriented, or logic languages. The most common high-level languages today are procedure-oriented languages. In these languages, one or more related blocks of statements that perform some complete function are grouped together into a program module, or procedure, and given a name such as “procedure A.” If the same sequence of operations is needed elsewhere in the program, a simple statement can be used to refer back to the procedure. In essence  , a procedure is just a mini-program. A large program can be constructed by grouping together procedures that perform different tasks. Procedural languages allow programs to be shorter and easier for the computer to read, but they require the programmer to design each procedure to be general enough to be used in different situations. 

​	Functional languages treat procedures like mathematical functions and allow them to be processed like any other data in a program. This allows a much higher and more **rigorous（严密）** level of program construction. Functional languages also allow variables—symbols for data that can be specified and changed by the user as the program is running—to be given values only once. This simplifies programming by reducing the need to be concerned with the exact order of statement execution, since a variable does not have to be **redeclared**, or **restated**, each time it is used in a program statement. Many of the ideas from functional languages have become key parts of many modern procedural languages. 

​	Object-oriented languages are **outgrowths（结果、副产物）** of functional languages. In object-oriented languages, the code used to write the program and the data processed by the program are grouped together into units called objects. Objects are further grouped into classes, which define the attributes objects must have. A simple example of a class is the class Book. Objects within this class might be Novel and Short Story. Objects also have certain functions associated with them, called methods. The computer accesses an object through the use of one of the object’s methods. The method performs some action to the data in the object and returns this value to the computer. Classes of objects can also be further grouped into **hierarchies（继承）**, in which objects of one class can inherit methods from another class. The structure provided in object-oriented languages makes them very useful for complicated programming tasks. 

​	Logic languages use logic as their mathematical base. A logic program consists of sets of facts and if-then rules, which specify how one set of facts may be **deduced（推导）** from others, for example: If the statement X is true, then the statement Y is false. In the execution of such a program, an input statement can be logically deduced from other statements in the program. Many artificial intelligence programs are written in such languages. 



**IV. LANGUAGE STRUCTURE AND COMPONENTS** 

​	Programming languages use specific types of statements, or instructions, to provide functional structure to the program. A statement in a program is a basic sentence that expresses a simple idea—its purpose is to give the computer a basic instruction. Statements define the types of data allowed, how data are to be manipulated, and the ways that procedures and functions work. Programmers use statements to manipulate common components of programming languages, such as variables and **macros（宏指令）** (mini-programs within a program). 

​	Statements known as data declarations give names and properties to elements of a program called variables. Variables can be assigned different values within the program. The properties variables can have are called types, and they include such things as what possible values might be saved in the variables, how much numerical **accuracy（精确）** is to be used in the values, and how one variable may represent a collection of simpler values in an organized fashion, such as a table or array. In many programming languages, a key data type is a pointer. Variables that are pointers do not themselves have values; instead, they have information that the computer can use to locate some other variable—that is, they point to another variable. 

​	An expression is a piece of a statement that describes a series of computations to be performed on some of the program’s variables, such as X+Y/Z, in which the variables are X, Y, and Z and the computations are addition and division. An assignment statement assigns a variable a value derived from some expression, while conditional statements specify expressions to be tested and then used to select which other statements should be executed next. 

​	Procedure and function statements define certain blocks of code as procedures or functions that can then be returned to later in the program. These statements also define the kinds of variables and parameters the programmer can choose and the type of value that the code will return when an expression accesses the procedure or function. Many programming languages also permit minitranslation programs called macros. Macros translate segments of code that have been written in a language structure defined by the programmer into statements that the programming language understands. 

**V. HISTORY**

​	Programming languages **date back（追溯）** almost to the invention of the digital computer in the 1940s. The first assembly languages **emerged（出现、浮现）** in the late 1950s with the introduction of commercial computers. The first procedural languages were developed in the late 1950s to early 1960s: FORTRAN, created by John Backus , and then COBOL, created by Grace Hopper  . The first functional language was LISP , written by John McCarthy in the late 1950s. Although heavily updated, all three languages are still widely used today.

​	 In the late 1960s, the first object-oriented languages, such as SIMULA , emerged. Logic languages became well known in the mid 1970s with the introduction of PROLOG , a language used to program artificial intelligence software. During the 1970s, procedural languages continued to develop with ALGOL , BASIC, PASCAL, C, and Ada . SMALLTALK was a highly influential object-oriented language that led to the merging of object-oriented and procedural languages in C++ and more recently in JAVA  . Although pure logic languages have declined in popularity, variations have become **vitally（极其）** important in the form of relational languages for modern databases, such as SQL . 



## 07-10:

Visual C++ and MFC Basics 

​	Visual C++ is much more than a compiler. It is a complete application development environment that, when used as intended, lets you fully **exploit(开发)** the object-oriented nature of C++ to create professional Windows applications. To take advantage of these features, you need to understand the C++ programming language. You must then understand the Microsoft Foundation Class (MFC ) **hierarchy（等级、层次）**. This class hierarchy **encapsulates（简要概括）** the user interface portion of the Windows API , supplies other useful classes, and makes it significantly easier to create Windows applications in an object-oriented way.

​	Let’s say you want to create a Windows application. You might, for example, need to create a specialized text or drawing editor, or a program that finds files on a large network, or an application that lets a user visualize the **interrelationships（关系）** in a big data set. Where do you begin? 

​	A good starting place is the design of the user interface. First, decide what the user should be able to do with the program, and then pick a set of user interface objects accordingly. The Windows user interface has a number of standard controls, such as buttons, menus, scroll bars, and lists, that are already familiar to Windows users. With this in mind, you can choose a set of controls and decide how they should be arranged on screen. You might start with a **rough sketch（草图）** of the interface if the program is small, or go through a complete user interface specification and design cycle if the program is large. 

​	The next step is to implement the code. When creating a program for any Windows platform, the programmer has two choices: C or C++. With C, the programmer codes at the level of the Windows Application Program Interface (API). This interface consists of a collection of hundreds of C functions described in the Window’s API reference books. 

​	When you use MFC, you write code that creates the necessary user interface controls and **customizes（定制）** their appearance. You also write code that responds when the user manipulates these controls. For example, if the user clicks a button, you want to have code in place that responds appropriately. It is this sort of event-handling code that will form the bulk of any application. Once the application responds correctly to all of the available controls, it is finished. 

​	All window-based GUIs contain the same basic elements and all operate in the same way. On screen the user sees a group of windows, each of which contains controls, icons, objects, and so on that are manipulated with the mouse or the keyboard. The interface objects seen by the user are the same from system to system: push buttons, scroll bars, icons, dialog boxes, pull-down menus, etc. These interface objects all work the same way, although some have minor differences in their “look and feel.” For example, scroll bars look slightly different as you move from Windows to the Mac, but they all do the same thing. 

​	From a programmer’s standpoint, the systems are all similar in concept, although they differ **radically（彻底、根本）** in their specifics. To create a GUI program, the programmer first puts all the needed user interface controls into a window. For example, if the programmer is trying to create a simple program such as a Fahrenheit to Celsius converter, then the programmer selects user interface objects appropriate to the task and displays them on screen. In this example, the programmer might let the user enter a temperature in an editable text area, display the converted temperature in another un-editable text area, and let the user exit the program by clicking on a push button labeled “Quit.” This structure is shown in Figure 4B-1.

​	As the user manipulates the application’s controls, the program must respond appropriately. For example, if the user clicks the Quit button, the button must update the screen appropriately, highlighting itself as necessary. Then the program must respond by quitting. Normally the button manages its appearance itself, and the program in some way receives a message from the button that says, “The Quit button was pressed. Do something about it.” The program responds by exiting. 

​	Windows follows this same general pattern. In a typical application you will create a main window and place inside it different user interface controls. These controls are often referred to as child windows—each control is like a smaller and more specialized sub-window inside the main application window. As the application programmer, you manipulate the controls by sending them messages via function calls, and they respond to user actions by sending messages back to your code. 

​	If you have never done any “event-driven” programming, then all of this may seem foreign to you. However, the event-driven style of programming is easy to understand when compared to a normal command-driven user interface. 

​	In a command-driven user interface, the system interacts with the user in three steps. First, the system prompts the user for a command. The prompt could be something explanatory such as: 

​	Please enter the next command> Or it could be something more obtuse: % 

​	The user is expected to know all the commands in the system and to type whichever one is needed. Second, the user types a command at the prompt and the system reads it. Third, the system parses the command and any modifiers following the command. The parsing step allows the system to call appropriate code to “execute” the command. Once command execution is complete, the program issues a new command prompt and the cycle repeats. Users of DOS or UNIX are familiar with this process. 

​	An event-driven user interface works somewhat differently. The exact details depend on the system and the level at which you are interfacing with it, but the basic concepts are similar. In an event-driven interface, the application paints several (or many) user interface objects such as buttons, text areas, and menus onto the screen. Now the application waits—typically in a piece of code called an event loop—for the user to do something. The user can do anything to any of the objects on screen using either the mouse or the keyboard. The user might click one of the buttons, for example. The mouse click is called an event. Event-driven systems define events for user actions such as mouse clicks and keystrokes, as well as for system activities such as screen updating.

​	At the lowest level of abstraction, you have to respond to each event in a fair amount of detail. This is the case when you are writing normal C code directly to the API. In such a scenario, you receive the mouse-click event in some sort of structure. Code in your event loop looks at different fields in the structure, determines which user interface object was affected, perhaps highlights the object in some way to give the user visual feedback, and then performs the appropriate action for that object and event. When there are many objects on the screen, the application becomes very large. It can take quite a bit of code simply to figure out which object was clicked and what to do about it. 

​	Fortunately, you can work at a much higher level of abstraction. In MFC, almost all these low-level implementation details are handled for you. If you want to place a user interface object on the screen, you create it with two lines of code. If the user clicks on a button, the button does everything needed to update its appearance on the screen and then calls a pre-arranged function in your program. This function contains the code that implements the appropriate action for the button. MFC handles all the details for you: you create the button and tell it about a specific handler function, and it calls your function when the user presses it. The labor involved in creating MFC applications is almost completely devoted to the creation of the handler functions. One of the best ways to begin understanding the structure and style of a typical MFC program is to enter, compile, and run a small example. Listing 4B-1 contains a simple “Hello World” program. The goal is to use the Visual C++ environment to create, compile, and execute this simple program. 

​	This small program does three things. First, it creates an “application object.” Every MFC program you write will have a single application object that handles the initialization details of MFC and Windows. Next, the application creates a single window on the screen to act as the main application window. Finally, inside that window the application creates a single static text label containing the words “Hello World.” The steps necessary to enter and compile this program are **straightforward（简单的）**. If you have not yet installed Visual C++ on your machine, do so now. You will have the option of creating standard and custom installations. 

